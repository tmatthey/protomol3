\documentclass[11pt]{report}
\usepackage{fullpage}
\usepackage{graphicx}
%\usepackage{longtable}
%\usepackage{multirow}
\usepackage{psfig}
\usepackage{amsmath}
%\usepackage{amsthm}
%\usepackage{amsfonts}
%\usepackage{amssymb}
\usepackage{times} 

\newcommand{\comment}[1]{\textit{\small {#1}}}
\newcommand{\cpp}{C\texttt{++}\ }
\newcommand{\tcl}{\textsc{Tcl\ }}
\newcommand{\ProtoMol}{\textsc{ProtoMol }}
\newcommand{\MDL}{\textsc{MDL\ }}
\newcommand{\MOLLY}{\textsc{MOLLY\ }}

\newcommand{\tempstart}{\texttt{<}}
\newcommand{\tempend}{\texttt{>}}
\newcommand{\rij}{\mbox{r$_{ij}$}}
\newcommand{\rik}{\mbox{r$_{ik}$}}
\newcommand{\vrij}{\mbox{$\vec{r}_{ij}$}}
\newcommand{\Si}[1]{\mbox{Si$_{#1}$}}
\newcommand{\Vr}[1]{\mbox{$\vec{r}_{#1}$}}
\newcommand{\Vx}[1]{\mbox{$\vec{x}_{#1}$}}
\newcommand{\Vv}[1]{\mbox{$\vec{v}_{#1}$}}
\newcommand{\hatr}[1]{\mbox{$\hat{{r}_{#1}}$}}
\newcommand{\hatv}[1]{\mbox{$\hat{{v}_{#1}}$}}
\newcommand{\AbsVr}[1]{\mbox{$\left| \vec{r}_{#1} \right| $}}
\newcommand{\AbsVv}[1]{\mbox{$\left| \vec{v}_{#1} \right| $}}
\providecommand{\textinmath}[1]{\mbox{#1}}
\providecommand{\ttsmall}[1]{\texttt{\small\mbox{#1}}}

\renewcommand{\labelenumiii}{\arabic{enumiii}.}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\author{
%  \begin{tabular}{cc}
%   Jes\'{u}s A. Izaguirre       & Thierry Matthey \\
%   Department of Computer Science      & Department of Informatics\\
%   University of Notre Dame      & University of Bergen \\
%     USA               & Norway \\
%    {\it izaguirr@cse.nd.edu} & {\it matthey@ii.uib.no} \\
%        &
%  \end{tabular}\\ \\ \\
%  \centerline{\ttsmall{http://www.nd.edu/\~{ }lcls}}\\
%  \centerline{\it protomol@cse.nd.edu}\\ 
%  ~\\ \\
%  \centerline{Contributors from University of Notre Dame:}\\ \\ \\
%  \centerline{Atul Bahel}\\ \\ \\
%  \centerline{Trevor Cickovski}\\
%  \centerline{Scott Hampton}\\
%  \centerline{Hong Hu}\\
%  \centerline{Qun Ma}\\
%  \centerline{Branden Moore}\\
%  \centerline{Thomas Slabach}\\
%  \centerline{Jeffrey Stine}\\
%  \centerline{George Viamontes}\\
%  \centerline{Jeremiah Willcock}\\
%~\\ \\ \\
%  \centerline{Edited by:} \\ \\
%  \centerline{Jim Bilek} \\ \\
% }
\title{\MDL - User Guide}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\maketitle
\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\begin{abstract}

%This user guide details the operation and key features of the
%\ProtoMol program.  \ProtoMol is designed to be an important tool for
%Molecular Dynamics (MD) simulations.  With a simple
%configuration setup, compatibility with other popular MD file formats,
%and the ability to run on parallel systems, Protomol combines high
%performance and ease of use. \\

%The user guide begins with a short introduction to the useful
%features of \ProtoMol and follows with the necessary setup and commands
%needed to run the software.  Also included is information on getting
%\ProtoMol up and running on parallel systems, procedures for integration
%with VMD, and
%instructions on how to download and install the latest version.  Finally,
%the appendices provide some background on Molecular Dynamics and the
%license for the use of this software.

%\end{abstract}


\chapter{Introduction}

This User Guide provides a summary for the operation of the
Molecular Dynamics Language (MDL), a domain-specific language
for prototyping, testing and debugging molecular dynamics (MD)
simulations.

MDL currently possesses the following capabilities:
\begin{enumerate}
\item {\bf Ability to construct physical systems}.  MDL file readers
accept input from PDB and CHARMM PSF and PAR files, as well as from XYZ
coordinate files for positions and velocities.  MDL can also work
with DCD trajectory files.  Other physical parameters such as boundary
conditions, Kelvin temperature, cell basis vectors (for periodic boundary
conditions (PBC) only), etc. can be controlled by the user.
\item {\bf Ability to specify which forces to evaluate}.  MDL includes 
a set of forces - including all bonded forces (accounting for deviations
of bonds, angles, dihedrals and impropers from equilibrium points), and
the nonbonded van der Waals and electrostatic forces.  Each simulation
can define a subset of these forces to evaluate; for example all may desired 
or for some cases (a noble gas) only van der Waals is necessary.
In the future we plan to allow users to define their own force
algorithms; in this way they will be able to implement for example
constraints much easier.
\item {\bf Ability to optimize pairwise force evaluation}.  MDL provides
several options for avoiding the expensive \begin{math}O(n^{2})\end{math}
pairwise computation of van der Waals and electrostatic forces; for example
defining a point at which to cutoff the force computation and assume zero;
also the ability to use Ewald, Particle Mesh Ewald (\begin{math}O(n log n)\end{math}) and Multigrid (\begin{math}O(n)\end{math}) methods for electrostatic
evaluation.  To ensure numerical stability, MDL also includes several
{\it switching functions} which smooth force values that employ cutoffs
to zero, and these in turn can be customized using switch on and off points.
\item {\bf Ability to customize output according to needs}.  MDL can handle
plots, files and screen output for several different observables; such
as energy, volume, momentum, etc.  These types of outputs can in turn be 
customized by frequency, file name, or other dependencies (outlined in this 
user guide).  In addition, data can be exported to third-party visualization
tools such as VMD and Pmv.
\item {\bf Ability to run various propagation schemes, or construct new ones}.  MDL contains a solid set of predefined propagation schemes (i.e. Leapfrog,
Langevin, MOLLY methods) and also some sampling schemes (i.e. Hybrid Monte
Carlo and Umbrella).  These can be run from any point in the simulation
for any number of steps at any appropriate timestep.  In addition, MDL
permits the user to construct their own propagators; either as Python classes
or as straight-up functions which return phase space as a two-dimensional
array of position and velocity vectors.  These new propagators can in turn
be easily {\it registered} with the MDL back end for use in simulations.
Propagator and force schemes are handled internally by {\it factories}
which lazily instantiate appropriate objects at runtime.
\end{enumerate}

In addition, a benefit of using Python is that MDL becomes
compatible with third-party tools.  Some of the following open-source
libraries have proved useful and are included in the MDL framework:

\begin{enumerate}
\item {\bf Numerical Python (NumPy)}: This set of libraries
provides linear array structures which can be used in matrix operations
efficiently.  We use these structures to represent positions, velocities
and forces.  Thus these objects can subsequently be used in matrix
operations using Numpy.
\item {\bf Gnuplot}: A useful plotting library which is the default
library used as it comes standard on many Linux systems.
\item {\bf Matplotlib}: A more intricate plotting library which provides
a GUI with options for scrolling through, saving and zooming into
plots.
\item {\bf VMD}: Molecular positions can be sent to VMD Python
modules for interactive visualization.  We still are working on improving
speed of this interactivity and robustness.
\item {\bf Python Molecular Viewer (PMV)}: A molecular viewer completely
written in Python; we have developed a module loadable from the viewer
which runs MDL commands from a menu-based GUI.
\end{enumerate}

There are several future goals we are currently working on:
\begin{enumerate}
\item {\bf Perfecting the low-level linear arrays}.  As an old
version of MDL used an array of objects containing \begin{math}(x,y,z)\end{math} data members, the porting of the code to completely linear arrays
for NumPy is not yet complete.  We expect to achieve this soon.
\item {\bf Interacting with MDL through an IDE}.  There are several available Python IDEs; we hope to find one that is most appropriate; such that it is possible to for example view the contents of low-level structures throughout a simulation.  Ideally this IDE would be cross platform.
\item {\bf The ability to prototype force algorithms}.  We hinted at this earlier, but there are several occasions where a user might want to develop their own force algorithms.  A recent experience of prototyping the Finite Temperature String Method forced us to implement dihedral constraints; the interface for which is not adequate at this time.  We plan to improve the interface to make this possible.
\item {\bf A Windows version.}  Windows is always a popular operating system for biologists, so we must make our tool windows-compliant.
\end{enumerate}

\chapter{Simulation Setup}

Simulations can be run through a standard Python interpreter.
Alternatively, they can be setup as a Python file and run with
 the interpreter.  If a simulation is long and relatively static,
we recommend the latter approach.

\section{Importing Core Modules}

The first step in prototyping any MDL simulation is to
import core MDL modules:

\begin{verbatim}
from Physical import *
from Forces import *
from ForceField import *
from IO import *
from Propagator import *
\end{verbatim}

All five of these modules will be needed.  We discuss their
use in more detail now.

\section{Physical System}

The physical system describes attributes of the 
molecular system such as structure, coordinates, 
boundary conditions, pairwise exclusions, and temperature.
You will first want to declare a Python object
to contain this information:

\begin{verbatim}
phys = Physical()
\end{verbatim}

and then populate this structure accordingly.
Since it will be necessary to populate some of this
information using file input, you also must define an \texttt{IO}
object:

\begin{verbatim}
io = IO()
\end{verbatim}

We will later use this object for plotting and other
forms of output.

Coordinates for positions and velocities can be specified 
using PDB or XYZ files, like so:

\begin{verbatim}
phys.readPDBPos(phys, "examples/bpti_water_1101/bpti.pdb")
phys.readPDBVel(phys, "examples/bpti_water_1101/bpti.vel.xyz")
\end{verbatim}

Charmm parameter and PSF files specify structure and
extra information such as spring constants, equilibrium
lengths for bonds, etc:

\begin{verbatim}
io.readPSF(phys, "examples/bpti_water_1101/bpti.psf")
io.readPAR(phys, "examples/bpti_water_1101/bpti.par")
\end{verbatim}

The physical structure contains default
values for other parameters such as boundary conditions.
However, you can specify these as well through the \texttt{Physical}
object:

\begin{verbatim}
phys.bc = "Periodic"        # Boundary conditions
phys.cellsize = 4           # Periodic cell size
phys.exclude = "scaled1-4"  # Pairwise exclusion
phys.temperature = 300      # Kelvin temperature
phys.seed = 7536031         # Random number seed
\end{verbatim}


\section{Forces}

The next step to setting up a simulation is 
to specify which types of forces should be calculated.
This is done with two modules: \texttt{Forces}
and \texttt{ForceField}.  The most commonly evaluated
forces include the following:

\begin{enumerate}
\item Two-atom bond forces, resulting from deviations from
equilibrium lengths.
\item Three-atom angle forces.
\item Four-atom dihedral and improper forces.
\item Van der Waals forces (using LennardJones evaluation).
\item Electrostatic or Coulombic forces.
\end{enumerate}

The first three types take linear time to evaluate, and
the latter two are pairwise.  By default, the pairwise
forces are evaluated using a {\it direct} algorithm; meaning
that all pairs of atoms are considered without any kind
of distance cutoff.  The above forces can be
included by doing the following:

\begin{verbatim}
forces = Forces()                           # Declare a Forces object
ff = forces.makeForceField(phys, "charmm")  # Return a ForceField
\end{verbatim}

However, in certain situations (i.e. noble gases have no bonds)
we may not want all of the above forces.  We can include a subset
of these forces by not passing the \texttt{"charmm"} flag
when the \texttt{ForceField} is created, and adding a couple
of statements after:

\begin{verbatim}
forces = Forces()                           # Declare a Forces object
ff = forces.makeForceField(phys)            # Return a ForceField
ff.bondedForces("bd")                       # Bond and dihedral
ff.nonbondedForces("l")                     # Van der Waals
\end{verbatim}

For bonded forces, ``b''=bond, ``a''=angle, ``d''=dihedral
and ``i''=improper.  For nonbonded, ``l''=van der Waals
and ``c''= electrostatic.

As mentioned, by default all pairs of atoms are considered
for pairwise force evaluation.  However, this may not be 
what is desired.  For large systems, it will save time
to for example stop the force computation if the 
distance between two atoms is larger than a cutoff.
This can be done like so:

\begin{verbatim}
ff.setAlgorithm("LennardJones", "Cutoff")
ff.setCutoff("LennardJones", 6.5)
\end{verbatim}

You can specify the same parameters for
van der Waals and electrostatic as follows:

\begin{verbatim}
ff.setAlgorithm("LennardJonesCoulomb", "Cutoff")
ff.setCutoff("LennardJonesCoulomb", 6.5)
\end{verbatim}

Several different algorithms can be specified
for pairwise forces. \texttt{"Cutoff"}, shown
above, assumes that after a certain distance
the force is zero.  \texttt{"SimpleFull"} is the
default and considers all pairs of atoms. In some
cases with Periodic Boundary Conditions, we want to
consider pairs of atoms which extend outside the original
box.  This can be done with a \texttt{Full} algorithm.
In addition \texttt{Ewald}, \texttt{PME} (Particle Mesh
Ewald) and \texttt{MultiGrid} can be specified
as fast algorithms for \texttt{Coulomb} for calculating
these electrostatic forces.

For the purposes of numerical stability, when
using cutoffs it is customary to {\it smooth} the
force to zero at the cutoff, rather than abruptly
dropping its value to zero.  This is done through
the use of switching functions:

\begin{verbatim}
ff.setSwitching("LennardJonesCoulomb", "C1")
\end{verbatim}

You can specify different functions for 
\texttt{"LennardJones"} and \texttt{"Coulomb"} but
keep the atom pair evaluation together for efficiency:

\begin{verbatim}
ff.setSwitching("LennardJonesCoulomb", "C1", "Shift")
\end{verbatim}

In addition, some extra parameter may be necessary.
For example, you may want to turn on the switching
at a specific distance value other than zero.  
To do that, use \texttt{extraparameters}:

\begin{verbatim}
ff.extraParameters("switchon=8.0")
\end{verbatim}

The following switching functions can be used:

\begin{enumerate}
\item \texttt{Universal} - no switching, default
\item \texttt{C1} - continuous first derivative
\item \texttt{C2} - continuous second derivative
\item \texttt{C3} or \texttt{C4} - for \texttt{MultiGrid}
\item \texttt{Cn} - flexible continuity, specified with \texttt{"order"} parameter
\item \texttt{Cutoff} - abruptly cutoff the value
\item \texttt{Shift} - avoids sudden force change through a potential shift
\end{enumerate}

Other parameters:

\begin{enumerate}
\item \texttt{blocksize} - not necessary for a \texttt{Cutoff} algorithm (32 by default)
\item \texttt{cutoff} - for a \texttt{Cutoff} switching function
\item \texttt{switchon} - distance at which the switching turns on
\item \texttt{switchoff} - distance at which the switching turns off
\item \texttt{order} - the continuity for a \texttt{Cn} switching function
\item {\bf For Ewald:}
\begin{enumerate}
\item \texttt{real} - turn on the real term
\item \texttt{reciprocal} - turn on the reciprocal term
\item \texttt{correction} - turn on the correction term
\item \texttt{alpha}
\item \texttt{accuracy}
\item \texttt{j} - expansion factor in Ewald sum
\end{enumerate}
\item {\bf For PME:}
\begin{enumerate}
\item \texttt{real} - turn on the real term
\item \texttt{reciprocal} - turn on the reciprocal term
\item \texttt{correction} - turn on the correction term
\item \texttt{interpolation} - \texttt{BSpline} (default) or \texttt{Hermite}
\item \texttt{alpha}
\item \texttt{accuracy}
\item \texttt{j} - expansion factor in Ewald sum
\item \texttt{nx}, \texttt{ny}, \texttt{nz} - mesh size
\end{enumerate}
\item {\bf For MultiGrid:}
\begin{enumerate}
\item \texttt{direct} - turn on the direct computation term
\item \texttt{correction} - turn on the correction term
\item \texttt{smooth} - turn on the smoothing term
\item \texttt{interpolation} - \texttt{BSpline} (default) or \texttt{Hermite}
\item \texttt{nx}, \texttt{ny}, \texttt{nz} - grid size (def. 5x5x5)
\item \texttt{levels} - number of interpolation levels
\item \texttt{s} - softening distance, default 1
\item \texttt{order} - interpolation order, default 4
\item \texttt{ratio} - fine to coarse grid ratio, default 2
\item \texttt{hx} - mesh size of the finest grid (VBC only, def. 5x5x5)
\item \texttt{ox} - origin of the finest grid (VBC only, def. 0x0x0)
\end{enumerate}
\end{enumerate}



\section{Output}

We saw earlier that MDL I/O can be accomplished in the form
of file input.  We can also run plots, and different types of output
during a simulation run to check and verify results.  Most types
of output have an associated {\it frequency} in timesteps
for which they run.  In addition, file output requires
a filename.  For example, we can use the {\it IO}
object that we declared earlier to output to the screen
every other timestep and to plot total energy every timestep:

\begin{verbatim}
io.plotTotalEnergy(1)
io.writeMomentum("bpti.out.mom", 5)
io.printScreen(2)
\end{verbatim}

The following \texttt{IO} member functions can be used
for plots; their names are self-explanatory.  Each of them
take an argument for the frequency:

\begin{enumerate}
\item \texttt{plotTotalEnergy}
\item \texttt{plotKineticEnergy}
\item \texttt{plotPotentialEnergy}
\item \texttt{plotTemperatures}
\item \texttt{plotPressures}
\item \texttt{plotVolumes}
\item \texttt{plotBondEnergies}
\item \texttt{plotAngleEnergies}
\item \texttt{plotDihedralEnergies}
\item \texttt{plotImproperEnergies}
\item \texttt{plotLennardJonesEnergies}
\item \texttt{plotCoulombEnergies}
\item \texttt{plotShadowEnergies}
\end{enumerate}

File output can be specified with the following routines,
which always accept a filename and a frequency.  If there are extra
parameters, they are indicated:

\begin{enumerate}
\item \texttt{writeTemperature} - output the Kelvin temperature, one extra parameter (boolean default false) for whether or not to separate water.
\item \texttt{writeEnergies} - output a table of all energies, two extra parameters (both booleans default false); the first designates whether or not to account for molecular temperature and the second designates whether shadow energy should be output.
\item \texttt{writeMomentum} - output the momentum.
\item \texttt{writeDihedrals} - output dihedral angles and radians, two extra parameters (first bool default false, second string default empty); the first designates whether or not to input dihedral information from a file, the second is that file if the first is true.
\item \texttt{writeDCDTrajectory} - output a DCD trajectory file of atomic positions.
\item \texttt{writeDiffusion} - output diffusion speed, volume, temperature and density.
\item \texttt{writePDBFramePos} - write positions to a PDB snapshot.
\item \texttt{writeXYZTrajectoryForce} - write an XYZ trajectory file of atomic forces.
\item \texttt{writeXYZTrajectoryForce} - write an XYZ trajectory file of atomic positions.
\item \texttt{writeXYZTrajectoryForce} - write an XYZ trajectory file of atomic velocities.
\end{enumerate}

In addition, as mentioned above \texttt{printScreen} will print data to the screen, including step number, total energy and total volume.


\section{Propagation Scheme}

The final step in an MD simulation is to specify the propagation
scheme and propagate the system.  This is done using the MDL \texttt{Propagator}
module.  The first step is to declare a \texttt{Propagator} object:

\begin{verbatim}
prop = Propagator()
\end{verbatim}

This object contains a method \texttt{propagate()} which propagates
the molecular system and returns the positions and velocities
as fast Numerical Python arrays.  In the statement below,
we run the Leapfrog method and store our results in a variable
\texttt{gamma} conducive for phase space:

\begin{verbatim}
gamma = prop.propagate("Leapfrog", phys, forces, io, 100, 0.5, ff)
\end{verbatim}

In the call to \texttt{propagate()}, the \texttt{Physical},
\texttt{Forces} and \texttt{IO} objects get passed, followed by the
number of steps to run, then the timestep, then the \texttt{ForceField}.
Leapfrog is a {\it single timestepping (STS) integrator}, as it evaluates
all forces at the same timesteps.
In some situations we use a {\it multiple timestepping integrator},
such as \texttt{Impulse}, which evaluates different forces
at different timesteps using an inner STS integrator which runs
at a higher frequency.  The following assumes Leapfrog
for the inner integrator, running 200 steps each consisting of 5 Leapfrog
steps at 0.1 fs each.  Note that we now use two force fields
and evaluate the more expensive nonbonded forces less often
than the bonded.

\begin{verbatim}
forces = Forces()
ff = forces.makeForceField(phys)
ff.nonbondedForces("lc")
ff2 = forces.makeForceField(phys)
ff2.bondedForces("badi")
....
gamma = prop.propagate("Impulse", phys, forces, io, 200, 5, ff, 0.1, ff2)
\end{verbatim}

Some propagators expect additional parameters.  Each propagator
defines default values for these parameters, but it is possible for the
user to control their values in the call to \texttt{propagate()}.
For example, Langevin dynamics inserts a damping term into
the energy equation with a coefficient \begin{math} \gamma \end{math}.
We can control this by passing an extra tuple to \texttt{propagate()}:

\begin{verbatim}
gamma = prop.propagate("LangevinImpulse", phys, forces, io, 10, 0.1, ff, 
                       ('gamma', 0.3))
\end{verbatim}

All predefined propagators, along with their timestepping, parameters and default values are specified below:

\begin{itemize}
\item \texttt{BBK}, STS
\begin{enumerate}
\item \texttt{temp} (300)
\item \texttt{gamma} (2)
\item \texttt{seed} (1234)
\end{enumerate}
\item \texttt{LangevinImpulse}, STS
\begin{enumerate}
\item \texttt{temp} (300)
\item \texttt{gamma} (2)
\item \texttt{numsteps} (0)
\item \texttt{seed} (1234)
\end{enumerate}
\item \texttt{Leapfrog}, STS
\item \texttt{NoseHoover}, STS
\begin{enumerate}
\item \texttt{temp} (300)
\item \texttt{inertia} (0,5)
\item \texttt{bathpos} (1.0)
\end{enumerate}
\item \texttt{NPTVerlet}, STS
\begin{enumerate}
\item \texttt{temp} (300)
\item \texttt{pressure} (100)
\item \texttt{omegaTo} (0.5)
\item \texttt{omegaTv} (2.5)
\item \texttt{tauP} (1.5)
\end{enumerate}
\item \texttt{NVTVerlet}, STS
\begin{enumerate}
\item \texttt{temp} (300)
\item \texttt{omegaTo} (0.5)
\end{enumerate}
\item \texttt{PositionVerlet}, STS
\item \texttt{SelfconsistentLeapfrog}, STS
\begin{enumerate}
\item \texttt{iter} (5)
\item \texttt{gamma} (0.5)
\item \texttt{temp} (300)
\item \texttt{seed} (1234)
\end{enumerate}
\item \texttt{BsplineMolly}, MTS
\begin{enumerate}
\item \texttt{type} (\texttt{short})
\item \texttt{stepsize} (0.1)
\end{enumerate}
\item \texttt{EquilibriumMolly}, MTS
\item \texttt{HMC}*, MTS
\begin{enumerate}
\item \texttt{cyclength} (1)
\item \texttt{temp} (285)
\end{enumerate}
\item \texttt{Impulse}, MTS
\item \texttt{ShadowHMC}*, MTS
\begin{enumerate}
\item \texttt{temp} (285)
\item \texttt{order} (4)
\item \texttt{C} (4.0)
\item \texttt{optimize} (0)
\item \texttt{ratio} (2)
\end{enumerate}
\item \texttt{Umbrella}*, MTS
\end{itemize}

* Hybrid Monte Carlo (HMC) methods and Umbrella are actually
sampling methods, implemented as multiple timestepping propagators.

\newpage
\section{Example: Four-atom Butane molecule, running Langevin dynamics (NVT)}

\begin{verbatim}




# IMPORT MODULES
from Physical import *
from Forces import *
from Propagator import *
from IO import *
from ForceField import *


# PHYSICAL SYSTEM
phys = Physical()
phys.bc = "Periodic"
phys.temperature = 200

# INPUT
io = IO()
io.readPDBPos(phys, "examples/UA_butane/UA_butane.pdb")
io.readPSF(phys, "examples/UA_butane/UA_butane.psf")
io.readPAR(phys, "examples/UA_butane/UA_butane.par")

# FORCES
forces = Forces()
ff = forces.makeForceField(phys, "charmm")
 
# OUTPUT
# PLOT TOTAL ENERGY EVERY 4 STEPS
io.plotTotalEnergy(4)
# WRITE TO THE SCREEN EVERY 2 STEPS
io.printScreen(2)

# PROPAGATE 50 STEPS OF LANGEVIN IMPULSE AT
# A TIMESTEP OF 0.1 FS
prop = Propagator()
gamma = prop.propagate("LangevinImpulse", phys, forces, io, 50, 0.1, ff)

# PRINT RESULT
print gamma
\end{verbatim}


\newpage
\section{Example: Solvated Bovine Pancreatic Tripsin Inhibitor (BPTI) running Leapfrog (NVE) using Particle-Mesh Ewald for Electrostatic Forces}

\begin{verbatim}
# IMPORT MODULES
from Physical import *
from Forces import *
from Propagator import *
from IO import *
from ForceField import *

# PHYSICAL
phys = Physical()
phys.bc = "Periodic"
phys.cellsize = 4
phys.exclude = "scaled1-4"
phys.temperature = 300
phys.seed = 7536031

# INPUT
io = IO()
io.readPDBPos(phys, "examples/bpti_water_1101/bpti.pdb")
io.readPSF(phys, "examples/bpti_water_1101/bpti.psf")
io.readPAR(phys, "examples/bpti_water_1101/bpti.par")

# FORCES
# MAKE A FORCE FIELD WITH ALL DEFAULT FORCES
forces = Forces()
ff = forces.makeForceField(phys, "charmm")

# VAN DER WAALS
# CUTOFF AFTER 6.5 ANGSTROMS
# SWITCH USING C2 SWF, TURN ON AT 0.1 ANGSTROMS
ff.setCutoff("LennardJones", 6.5)
ff.setAlgorithm("LennardJones", "Cutoff")
ff.setSwitching("LennardJones", "C2")
ff.setParameters("LennardJones", "switchon=0.1")

# ELECTROSTATIC
# CUTOFF AFTER 6.5 ANGSTROMS
# SWITCH USING C1 SWF
# USE PARTICLE MESH EWALD FOR O(N LOG N) EVALUATION
ff.setCutoff("Coulomb", 6.5)
ff.setSwitching("Coulomb", "C1")
ff.setAlgorithm("Coulomb", "PME")

# OUTPUT
# WRITE ENERGIES FILE EVERY 5 STEPS
# PRINT TO THE SCREEN EVERY STEP
io.writeEnergies("bpti.out.energy", 5)
io.printScreen(1)

# EXECUTE 2000 STEPS AT TIMESTEP OF 0.5 FS
prop = Propagator()
gamma = prop.propagate("Leapfrog", phys, forces, io, 2000, 0.5, ff)
\end{verbatim}

\chapter{Defining a Propagator}

There are two ways to define a propagator in MDL.
The first specifies an actual Python class, allowing object
declarations.  The second constructs the propagator as a Python
method, which maps one phase space to the next.  We explore
both in this section.


\section{Object}

An integrator object consists of three optional function definitions:
\texttt{init}, \texttt{run} and \texttt{finish}.  Each takes three
parameters: a \texttt{Physical} object, a \texttt{Forces} object and
a \texttt{Propagator} object.  \texttt{Physical} gives access to 
information such as phase space (positions, velocities, plus regular
and inverse mass matrices), \texttt{Forces} allows invocations of
a \texttt{calculateForces} routine to update forces, and \texttt{Propagator}
allows access to the timestep, for instance.  The \texttt{init}
method is invoked once at the beginning of a propagation, the \texttt{run}
method at every step, and the \texttt{finish} method at the end.
We define a propagation by a single call to the \texttt{propagate()}
method of a \texttt{Propagator} object, which we saw above
in simulation prototyping.

The first step is to define a Python class, which inherits from
\texttt{STS} or \texttt{MTS} depending on if the propagator is single
or multiple timestepping, for example for Leapfrog:

\begin{verbatim}
class LeapfrogProp(STS):
\end{verbatim}

We will reference this propagator as \texttt{LeapfrogProp} to avoid
confusion with the predefined \texttt{Leapfrog} integrator in MDL.
A simple \texttt{init} method for Leapfrog propagation could look like this:

\begin{verbatim}
   def init(self, phys, forces, prop):
      prop.calculateForces(phys.positions, phys.velocities, forces.force)
      phys.velocities += forces.force*0.5*prop.timestep(self)*phys.invmasses
      phys.positions += phys.velocities*prop.timestep(self)
      prop.calculateForces(phys.positions, phys.velocities, forces.force)
\end{verbatim}

which does a half kick on velocities followed by a full kick on positions,
sandwiched by two updates of the forces.  We can then define a \texttt{run}
method which does a full kick on velocities and positions followed
by a force update:

\begin{verbatim}
   def run(self, phys, forces, prop):
      phys.positions += phys.velocities*prop.timestep(self)
      phys.velocities += forces.force*prop.timestep(self)*phys.invmasses
      prop.calculateForces(phys.positions, phys.velocities, forces.force)
\end{verbatim}

and finally a \texttt{finish} method which does one final half
kick on velocities:

\begin{verbatim}
   def finish(self, phys, forces, prop):
      phys.velocities += forces.force*0.5*prop.timestep(self)*phys.invmasses
\end{verbatim}

It is not necessary to define all three of these methods; blank defaults
are used if they are undefined.  It is also not necessary to only define
these three methods; auxiliary methods can be used as well.

Modifiers can be specified in propagator object declarations.
There are a few predefined propagator modifiers in MDL, and each 
has a specific location where it executes.  For example, if we wanted
to change this \texttt{Leapfrog} propagator to run \texttt{NoseHoover},
we could access the predefined \texttt{friction} modifier which appends
a friction term to the forces, and tell it to execute after
every force calculation, like so:

\texttt{modifiers = [("friction","PostForce")]}

Modifiers defined in MDL include:
\begin{enumerate}
\item \texttt{friction}
\item \texttt{averagePositions}
\item \texttt{mollify}
\end{enumerate}

Their positions can be \texttt{PreInit}, \texttt{PostInit},
\texttt{PreRun}, \texttt{PostRun}, \texttt{PreForce} and 
\texttt{PostForce}.

The final step is to {\it register} the new propagator
with the back end.  This is done by specifying any 
the name of the object and its parameters.  Leapfrog takes
no parameters, but If we truly wanted
Nose-Hoover dynamics, we would need to specify a temperature,
thermal inertia and the bath position:

\begin{verbatim}
name="NH"
parameters=('temp', 300,
            'thermal', 0.8,
            'bathpos', 1.0)
\end{verbatim}


\section{Method}

For a propagation method, we do not define any Python class,
but only a Python function.   However, since we are no longer
dividing functionality into beginning, step and ending tasks,
we must now pass a few more parameters.  Specifically, in addition
to the \texttt{Physical}, \texttt{Forces}, \texttt{ForceField} 
and \texttt{Propagator} objects, the method must now know how many 
steps to run at what timestep.

We can define an example function header like so:
\begin{verbatim}
def leapfrog(phys, forces, prop, steps, timestep, fg):
\end{verbatim}

We then define the initialization functionality as the first
tasks to execute:

\begin{verbatim}
   prop.calculateForces(phys.positions, phys.velocities, forces.force)
   phys.velocities += forces.force*0.5*prop.timestep(self)*phys.invmasses
   phys.positions += phys.velocities*prop.timestep(self)
   prop.calculateForces(phys.positions, phys.velocities, forces.force)
\end{verbatim}

Subsequently, we declare the \texttt{run} functionality in
a loop from 1 to \texttt{steps}:

\begin{verbatim}
   for step in range (1, steps):
      phys.positions += phys.velocities*prop.timestep(self)
      phys.velocities += forces.force*prop.timestep(self)*phys.invmasses
      prop.calculateForces(phys.positions, phys.velocities, forces.force)
\end{verbatim}

And then the finishing half kick:

\begin{verbatim}
   phys.velocities += forces.force*0.5*prop.timestep(self)*phys.invmasses
\end{verbatim}

Now propagation methods must return positions and velocities:

\begin{verbatim}
   return [phys.positions, phys.velocities]
\end{verbatim}

Registration happens in the same way as for objects, using the
method name.

\newpage
\section{Example: Nose-Poincare Propagator Object}
\begin{verbatim}
class NosePoincGL(STS):
   def init(self, phys, forces, prop):
      self.bathPold = self.bathP  # OLD THERMOSTAT
      self.gkT = 3.0*(phys.numAtoms()-1.0)*Constants.boltzmann()*self.temp
      self.KEtoT = 2.0 / (3.0*(phys.numAtoms()-1.0)*Constants.boltzmann())
      prop.calculateForces(phys.positions, phys.velocities, forces.force)
      self.Potnl = forces.energies.potentialEnergy()
      self.h0 = self.Potnl + forces.energies.kineticEnergy(phys)
      self.stepsdone = 0
      self.avTemp = 0
      self.tempers = []
      self.Hamiltonian = []

   #  run integrator for 'steps'
   #  1/2 step in momentum followed by 1/2 step in thermostat momentum
   #  followed by full step in positions, then 1/2 step in thermostat momentum
   #  and 1/2 step in momentum to give a time reversible method.
   def run(self, phys, forces, prop):

      #  update system velocity first 1/2 step
      phys.velocities += forces.force*0.5*prop.timestep(self)*phys.invmasses

      #  update thermal bath 'momenta' first 1/2 step
      tempC = 0.5*prop.timestep(self)*(self.gkT*(1.0 + log(self.bathP))
         -forces.energies.kineticEnergy(phys)+self.Potnl-self.h0)-self.bathM
      self.bathM = -2*tempC / (1.0 
         + sqrt(1.0 - tempC*prop.timestep(self)/self.Q))

      #  update positions and thermal bath variable full step
      self.bathPold = self.bathP
      tempF = 0.5*prop.timestep(self)*self.bathM/self.Q
      self.bathP *= (1.0 + tempF)/(1.0 - tempF)
      phys.positions += phys.velocities*self.bathPold*0.5*prop.timestep(self)
                           *(1.0/self.bathP+1.0/self.bathPold)

      prop.calculateForces(phys.positions, phys.velocities, forces.force)

      self.Potnl = forces.energies.potentialEnergy()

      #  update thermal bath 'momenta' second 1/2 step
      tempS = self.bathPold/self.bathP
      tempS *= tempS
      self.bathM += 0.5*prop.timestep(self)*
                (forces.energies.kineticEnergy(phys)*tempS-self.gkT
                *(1.0+log(self.bathP))-self.Potnl+self.h0-0.5*self.bathM
                *self.bathM/self.Q)

      #  update system velocity second 1/2 step
      tempS = self.bathPold/self.bathP
      phys.velocities = phys.velocities*tempS + 
          forces.force*0.5*prop.timestep(self)*phys.invmasses

      #  store average temperature
      self.avTemp += forces.energies.kineticEnergy(phys)*self.KEtoT
      self.stepsdone += 1

   def finish(self, phys, forces, prop):
      self.tempers.append([self.stepsdone,self.avTemp/self.stepsdone])
      self.Hamiltonian.append([self.stepsdone,self.bathP
                *(forces.energies.kineticEnergy(phys)
                +forces.energies.potentialEnergy()+0.5*self.bathM
                *self.bathM/self.Q+self.gkT*log(self.bathP)-self.h0)])
      

# REGISTER THE NEW PROPAGATOR      
name="NosePoincGL"
parameters=('temp', 500,
            'bathM', 0.0,
            'bathP', 1.0,
            'Q', 10.0)

\end{verbatim}


\newpage
\section{Example: BBK Propagator Method}

\begin{verbatim}
# REDEFINING THE BBK PROPAGATOR AS A bbk METHOD
def bbk(phys, forces, prop, steps, timestep, ff, temp, gamma, seed):
   timestep = timestep*Constants.invTimeFactor()
   
   # USE THE FORCE FIELD TO CALCUATE FORCES
   ff.calculateForces(phys.positions, phys.velocities, forces.force)

   # INITIALIZE LOOP
   step = 0
   while (step < steps):

       # F = F_rand*sqrt(2*k*T*gamma/dt)
       forceconstant = 2*Constants.boltzmann()*temp*gamma/timestep
       forces.force += prop.randomForce(phys,seed)*sqrt(forceconstant)

       # V *= (1-0.5*dt*gamma)
       phys.velocities = phys.velocities * (1.0-0.5*timestep*gamma)

       # V += 0.5*F*dt*M^-1
       phys.velocities = phys.velocities + forces.force*
                         0.5*timestep*phys.invMass()

       # P += V*dt
       phys.positions = phys.positions + phys.velocities*timestep

       # CALCULATE FORCES AGAIN
       fg.calculateForces(phys.positions, phys.velocities, forces.force)

       # F = F_rand*sqrt(2*k*T*gamma/dt)
       forceconstant = 2*Constants.boltzmann()*temp*gamma/timestep
       forces.force += prop.randomForce(phys,seed)*sqrt(forceconstant)

       # V += 0.5*F*dt*M^-1
       phys.velocities += forces.force*0.5*timestep*phys.invMass()

       # V *= (1.0/(1.0+0.5*dt*gamma))
       phys.velocities *= (1.0/(1.0+0.5*timestep*gamma))         

       # NEXT STEP
       step = step + 1

   # RETURN POSITIONS AND VELOCITIES
   return [phys.positions, phys.velocities]


# REGISTER THE PROPAGATOR NAME
name="bbk"


# REGISTER THE PROPAGATOR PARAMETERS
# AND DEFAULTS
parameters=("temp", 300,
            "gamma", 0.5,
            "seed", 1234)
\end{verbatim}

\chapter{Complete Example: Finite Temperature String Method}

We have shown how to use MDL to prototype propagation
schemes.  Now we demonstrate the use of MDL to construct
a more complex numerical method used to determine the 
most probable conformational path between two metastable
states of a molecule.



\end{document}
